/* 
 * Boost Software License - Version 1.0 - August 17th, 2003
 * 
 * Copyright (c) 2013-2014 Developed by reg <entry.reg@gmail.com>
 * 
 * Permission is hereby granted, free of charge, to any person or organization
 * obtaining a copy of the software and accompanying documentation covered by
 * this license (the "Software") to use, reproduce, display, distribute,
 * execute, and transmit the Software, and to prepare derivative works of the
 * Software, and to permit third-parties to whom the Software is furnished to
 * do so, all subject to the following:
 * 
 * The copyright notices in the Software and this entire statement, including
 * the above license grant, this restriction and the following disclaimer,
 * must be included in all copies of the Software, in whole or in part, and
 * all derivative works of the Software, unless such copies or derivative
 * works are solely in the form of machine-executable object code generated by
 * a source language processor.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
 * SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
 * FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE. 
*/

using System;
using System.Collections;
using System.Collections.Concurrent;
using System.Collections.Generic;
using System.Diagnostics;
using System.IO;
using System.Linq;
using System.Text;
using System.Text.RegularExpressions;
using EnvDTE80;
using Microsoft.Build.Collections;
using Microsoft.Build.Evaluation;
using Microsoft.VisualStudio.Shell.Interop;
using net.r_eg.vsSBE.Exceptions;
using net.r_eg.vsSBE.MSBuild;

namespace net.r_eg.vsSBE
{
    public class MSBuildParser: IMSBuildProperty, ISBEParser
    {
        /// <summary>
        /// Provides operation with environment
        /// </summary>
        protected IEnvironment env;

        /// <summary>
        /// Definitions of user scripts
        /// </summary>
        protected ConcurrentDictionary<string, string> definitions = new ConcurrentDictionary<string, string>();

        /// <summary>
        /// object synch.
        /// </summary>
        private Object _eLock = new Object();

        /// <summary>
        /// MSBuild Property from default Project
        /// </summary>
        /// <param name="name">key property</param>
        /// <returns>evaluated value</returns>
        public string getProperty(string name)
        {
            return getProperty(name, null);
        }

        /// <summary>
        /// MSBuild Property from specific project
        /// </summary>
        /// <param name="name">key of property</param>
        /// <param name="projectName">Specific project</param>
        /// <exception cref="MSBPropertyNotFoundException"></exception>
        /// <returns>Evaluated value of property</returns>
        public virtual string getProperty(string name, string projectName)
        {
            if(projectName == null)
            {
                string slnProp = env.getSolutionGlobalProperty(name);
                if(slnProp != null) {
                    Log.nlog.Debug("Solution-context for getProperty - '{0}' = '{1}'", name, slnProp);
                    return slnProp;
                }
            }

            Project project         = env.getProject(projectName);
            ProjectProperty prop    = project.GetProperty(name);

            if(prop != null) {
                return prop.EvaluatedValue;
            }
            throw new MSBPropertyNotFoundException("variable - '{0}' : project - '{1}'", name, (projectName == null) ? "<default>" : projectName);
        }

        public List<TMSBuildPropertyItem> listProperties(string projectName = null)
        {
            List<TMSBuildPropertyItem> properties = new List<TMSBuildPropertyItem>();

            Project project = env.getProject(projectName);
            foreach(ProjectProperty property in project.Properties)
            {
                string eValue = property.EvaluatedValue;
                if(projectName == null)
                {
                    string slnProp = env.getSolutionGlobalProperty(property.Name);
                    if(slnProp != null) {
                        Log.nlog.Debug("Solution-context for listProperties - '{0}' = '{1}'", property.Name, slnProp);
                        eValue = slnProp;
                    }
                }

                properties.Add(new TMSBuildPropertyItem(property.Name, eValue));
            }
            return properties;
        }

        /// <summary>
        /// Evaluate data with the MSBuild engine.
        /// alternative to Microsoft.Build.BuildEngine - http://msdn.microsoft.com/en-us/library/Microsoft.Build.BuildEngine
        /// </summary>
        /// <param name="unevaluated">raw string as $(..data..)</param>
        /// <param name="projectName">push null if default</param>
        /// <returns>evaluated value</returns>
        public virtual string evaluateVariable(string unevaluated, string projectName)
        {
            const string container  = "vsSBE_latestEvaluated";
            Project project         = env.getProject(projectName);

            lock(_eLock)
            {
                try {
                    project.SetProperty(container, _wrapVariable(ref unevaluated));
                    return project.GetProperty(container).EvaluatedValue;
                }
                finally {
                    project.RemoveProperty(project.GetProperty(container));
                }
            }
        }

        /// <summary>
        /// Simple handler properties of MSBuild environment
        /// </summary>
        /// <param name="data">text with $(ident) data</param>
        /// <returns>text with evaluated properties</returns>
        [Obsolete("Use the parseVariablesMSBuild", false)]
        public string parseVariablesMSBuildSimple(string data)
        {
            return Regex.Replace(data, @"
                                         (?<!\$)\$
                                         \(
                                           (?:
                                             (
                                               [^\:\r\n)]+?
                                             )
                                             \:
                                             (
                                               [^)\r\n]+?
                                             )
                                             |
                                             (
                                               [^)]*?
                                             )
                                           )
                                         \)", delegate(Match m)
            {
                // 3   -> $(name)
                // 1,2 -> $(name:project)

                if(m.Groups[3].Success) {
                    return getProperty(m.Groups[3].Value);
                }
                return getProperty(m.Groups[1].Value, m.Groups[2].Value);

            }, RegexOptions.IgnoreCase | RegexOptions.IgnorePatternWhitespace).Replace("$$(", "$(");
        }

        public virtual string parseVariablesMSBuild(string data)
        {
            /*
                    (
                      \${1,2}
                    )
                    (?=
                      (
                        \(
                          (?>
                            [^()]
                            |
                            (?2)
                          )*
                        \)
                      )
                    )            -> for .NET: v             
             */
            return Regex.Replace(data,  @"(
                                            \${1,2}
                                          )
                                          (
                                            \(
                                              (?>
                                                [^()]
                                                |
                                                \((?<R>)
                                                |
                                                \)(?<-R>)
                                              )*
                                              (?(R)(?!))
                                            \)
                                          )", delegate(Match m)
            {
                // 1 - $ or $$
                // 2 - (name) or (name:project) or ([MSBuild]::MakeRelative($(path1), ...):project) .. 
                //      http://msdn.microsoft.com/en-us/library/vstudio/dd633440%28v=vs.120%29.aspx

                if(m.Groups[1].Value.Length > 1) { //escape
                    return m.Value.Substring(1);
                }

                return evaluateVariable(prepareVariables(m.Groups[2].Value));
            }, 
            RegexOptions.IgnorePatternWhitespace);
        }

        /// <summary>
        /// Internal processing.
        /// 
        /// All variables which are not included in MSBuild environment.
        /// Customization for our data.
        /// </summary>
        /// <param name="raw">Where to look</param>
        /// <param name="ident">Expected variable. What we're looking for..</param>
        /// <param name="vTrue">Value if found</param>
        /// <returns>String with evaluated data as vTrue value or unevaluated as is</returns>
        public virtual string parseVariablesSBE(string raw, string ident, string vTrue)
        {
            return Regex.Replace(raw, @"(
                                          \${1,2}     #1 -> $ or $$
                                        )
                                        \(
                                           (
                                             [^)]+?   #2 -> unevaluated data
                                           )
                                        \)", delegate(Match m)
            {
                if(m.Groups[2].Value != ident || m.Groups[1].Value.Length > 1) {
                    return m.Value;
                }
                return (vTrue == null)? "" : vTrue;
            }, RegexOptions.IgnorePatternWhitespace);
        }

        /// <param name="env">Used environment</param>
        public MSBuildParser(IEnvironment env)
        {
            this.env = env;
        }

        /// <param name="raw">raw data at format - '(..data..)'</param>
        /// <exception cref="IncorrectSyntaxException"></exception>
        protected TPreparedData prepareVariables(string raw)
        {
            TPreparedData ret = new TPreparedData();

            Match m = Regex.Match(raw.Trim(), @"^\(  
                                                   (?:
                                                     (\#)?           # 1 -> special char  (optional)
                                                     ([A-z_0-9]+)    # 2 -> variable name (optional)
                                                     \s*=\s*
                                                   )?
                                                   (?:
                                                      (.+)           # 3 -> unevaluated data
                                                      :([^)]+)       # 4 -> specific project for variable if 2 is present or for unevaluated data
                                                    |                # or:
                                                      (.+)           # 5 -> unevaluated data
                                                   )
                                               \)$", RegexOptions.IgnorePatternWhitespace);

            if(!m.Success) {
                Log.nlog.Debug("impossible to prepare data '{0}'", raw);
                throw new IncorrectSyntaxException("prepare failed - '{0}'", raw);
            }
            bool hasVar     = m.Groups[2].Success;
            bool hasProject = m.Groups[3].Success ? true : false;

            if(hasVar) {
                ret.variable.name           = m.Groups[2].Value.Trim();
                ret.variable.isPersistence  = (m.Groups[1].Success && m.Groups[1].Value == "#") ? true : false;
            }

            ret.property.raw = (hasProject ? m.Groups[3] : m.Groups[5]).Value.Trim();

            bool composite          = (ret.property.raw[0] == '$') ? true : false;
            ret.property.escaped    = (composite && ret.property.raw[1] == '$') ? true : false;

            if(hasProject)
            {
                string project = m.Groups[4].Value.Trim();

                if(!composite) {
                    ret.property.project = project;
                }
                else if(hasVar) {
                    ret.variable.project = project;
                }
                else {
                    // should be variable of variable e.g.: ($(var:project):project)
                    ret.property.project = project;
                }
            }

            ret.property.complex = !_isPropertySimple(ref ret.property.raw) || composite;

            if(!ret.property.complex) {
                ret.property.unevaluated = ret.property.raw;
                ret.property.completed   = true;
                Log.nlog.Debug("Prepared: simple - '{0}'", ret.property.unevaluated);
                return ret;
            }
            if(ret.property.escaped) {
                ret.property.unevaluated = ret.property.raw.Substring(1);
                ret.property.completed   = true;
                Log.nlog.Debug("Prepared: complex escaped - '{0}'", ret.property.unevaluated);
                return ret;
            }
            
            // try to simplify
            m = Regex.Match(ret.property.raw, @"^
                                                  \$
                                                  \(
                                                     ([A-z_0-9]+)     # 1 - name
                                                     (?::([^)]+))?    # 2 - project
                                                  \)
                                                $", RegexOptions.IgnorePatternWhitespace);

            if(m.Success)
            {
                ret.property.complex        = false;
                ret.property.unevaluated    = m.Groups[1].Value;
                ret.property.completed      = true;
                ret.property.project        = (m.Groups[2].Success) ?
                                                           m.Groups[2].Value.Trim() : 
                                                           (!String.IsNullOrEmpty(ret.property.project)) ? ret.property.project : null;
                
                Log.nlog.Debug("Prepared: found simple property '{0}' for '{1}'", ret.property.unevaluated, ret.property.project);
                return ret;
            }

            ret.property.unevaluated = ret.property.raw;

            // nested data
            ret = prepareNested(ret);

            ret.property.unevaluated = _wrapVariable(ref ret.property.unevaluated);
            Log.nlog.Debug("Prepared: step out");
            return ret;
        }

        protected string evaluateVariable(TPreparedData prepared)
        {
            string evaluated = String.Empty;
            
            if(prepared.property.completed && !prepared.property.complex)
            {
                string defindex = String.Format("{0}:{1}", prepared.property.unevaluated, prepared.property.project);

                if(definitions.ContainsKey(defindex)) {
                    Log.nlog.Debug("Evaluate: use the definitions");
                    evaluated = definitions[defindex];
                }
                else {
                    Log.nlog.Debug("Evaluate: use the getProperty");
                    evaluated = getProperty(prepared.property.unevaluated, prepared.property.project);
                }
            }
            else if(prepared.property.escaped){
                Log.nlog.Debug("Evaluate: escaped value");
                evaluated = prepared.property.unevaluated;
            }
            else
            {
                Log.nlog.Debug("Evaluate: use the evaluateVariable :: nested[{0}] {1}",
                                                                    prepared.property.nested.hasProperty,
                                                                    prepared.property.nested.nodes.Count);

                string unevaluated = prepared.property.nested.hasProperty ? buildNested(prepared.property.nested) : prepared.property.unevaluated;

                Log.nlog.Debug("Evaluate: ready to '{0}'", unevaluated);
                evaluated = evaluateVariable(unevaluated, prepared.property.project);
            }

            if(!String.IsNullOrEmpty(prepared.variable.name))
            {
                //INFO: prepared.variable.isPersistence - [reserved]
                string defindex = String.Format("{0}:{1}", prepared.variable.name, prepared.variable.project);
                Log.nlog.Debug("Variable of user: set '{0}' = '{1}'", defindex, evaluated);
                definitions[defindex] = evaluated;
                evaluated = "";
            }

            Log.nlog.Debug("Evaluated: '{0}'", evaluated);
            return evaluated;
        }

        /// <summary>
        /// Work with complex nested data
        /// </summary>
        /// <param name="data"></param>
        /// <param name="limit">Maximum of nesting level. Aborts if reached</param>
        /// <exception cref="MSBPropertyParseException"></exception>
        /// <exception cref="LimitException"></exception>
        /// <returns></returns>
        protected TPreparedData prepareNested(TPreparedData data, int limit = 50)
        {
            if(String.IsNullOrEmpty(data.property.unevaluated)) {
                throw new MSBPropertyParseException("the 'unevaluated' of TPreparedData is empty. raw == '{0}'", data.property.raw);
            }

            data.property.nested        = new TPreparedData.Nested();
            data.property.nested.nodes  = new Dictionary<int, List<TPreparedData.Nested.Node>>();
            string unevaluated          = data.property.unevaluated;

            string patternC = @"(
                                  (?:
                                      ""          # notice: "" - is a single double quote, i.e. escaped in @ mode
                                       (?:
                                          [^""\\]
                                        |
                                          \\""?
                                       )*""
                                   |
                                     '(?:
                                         [^'\\]
                                       |
                                         \\.'?
                                      )*'
                                  )
                                )            #1 - strings - "", ''
                                ([\s,)])     #2 - limiter symbol";


            string patternV = @"(?:
                                  (\${1,2})                  #1 - $ or $$
                                  \(
                                     (?:
                                        (
                                          [^$:()]+
                                          [^()]
                                        )                    #2 - name [Simple]
                                        (?:
                                          :
                                          (
                                            [^:]
                                            [^$()]+ [^()]
                                          )                  #3 - project [Simple] (optional)
                                        )?
                                      |
                                        (
                                          [^$:]+? \)?        #4 - name [Complex]
                                        )
                                        (?:
                                          :
                                          (
                                            [^:]
                                            [^$()]+ [^()]
                                           |
                                            [^:$]+?
                                            [^$)]+ \)?
                                          )                  #5 - project [Complex] (optional)
                                        )?
                                     )
                                  \)
                                  |
                                  !p!
                                )";

            Log.nlog.Debug("nested: started with '{0}'", unevaluated);
            Func<bool> h = null;
            h = delegate()
            {
                int level = data.property.nested.nodes.Count;

                if(level > limit) {
                    throw new LimitException("Nesting level of '{0}' reached. Aborted.", limit);
                }
                data.property.nested.nodes[level] = new List<TPreparedData.Nested.Node>();

                // string arguments

                unevaluated = Regex.Replace(unevaluated, patternC, delegate(Match m)
                {
                    data.property.nested.nodes[level].Add(
                        new TPreparedData.Nested.Node(m.Groups[1].Value, TPreparedData.Nested.TypeValue.String)
                    );
                    Log.nlog.Debug("nested: added string '{0}' :: level {1}", m.Groups[1].Value, level);

                    // no conflict, because all variants with '!' as argument is not possible without quotes.
                    return String.Format("!p{0}!{1}", level, m.Groups[2].Value);
                }, RegexOptions.IgnorePatternWhitespace);

                if(data.property.nested.nodes[level].Count > 0)
                {
                    data.property.nested.data = unevaluated;
                    //Log.nlog.Debug("nested: '{0}' :: level {1}", unevaluated, level);

                    level = data.property.nested.nodes.Count;
                    data.property.nested.nodes[level] = new List<TPreparedData.Nested.Node>();
                }

                // complex-type arguments

                data.property.nested.nodes[level] = _nestedComplex(data.property, ref patternV, ref unevaluated, level);

                if(data.property.nested.nodes[level].Count > 0) {
                    data.property.nested.data           = unevaluated;
                    data.property.nested.hasProperty    = true;
                    //Log.nlog.Debug("nested: '{0}' :: level {1}", unevaluated, level);
                }

                if(Regex.Match(unevaluated, patternV, RegexOptions.IgnorePatternWhitespace).Success
                    || Regex.Match(unevaluated, patternC, RegexOptions.IgnorePatternWhitespace).Success)
                {
                    Log.nlog.Debug("nested: step in");
                    h();
                }
                return true;
            };
            h();

            data.property.completed = true;
            data.property.complex   = true;

            Log.nlog.Debug("nested: completed");
            return data;
        }

        /// <summary>
        /// Final assembly for nested levels
        /// </summary>
        /// <param name="nested"></param>
        /// <exception cref="MismatchException"></exception>
        /// <returns></returns>
        protected string buildNested(TPreparedData.Nested nested)
        {
            string data = nested.data;
            Log.nlog.Debug("build nested: started with '{0}'", data);
            for(int level = nested.nodes.Count - 1; level >= 0; --level)
            {
                string placeholder                      = String.Format("!p{0}!", level);
                List<TPreparedData.Nested.Node> dropped = new List<TPreparedData.Nested.Node>();

                foreach(TPreparedData.Nested.Node node in nested.nodes[level])
                {
                    int pos = data.IndexOf(placeholder);
                    if(pos == -1) {
                        throw new MismatchException("Nodes is greater than the data. placeholder:{0} /data:{1}", placeholder, data);
                    }
                    string result;

                    if(node.type == TPreparedData.Nested.TypeValue.PropertyEscaped
                        || node.type == TPreparedData.Nested.TypeValue.String)
                    {
                        result = node.data;
                    }
                    else if(node.type == TPreparedData.Nested.TypeValue.Property) {
                        result = node.evaluated;
                    }
                    else {
                        result = node.data;
                    }

                    data = String.Format("{0}{1}{2}",
                                            data.Substring(0, pos),
                                            result,
                                            data.Substring(pos + placeholder.Length));

                    if(node.backLinkL != -1) {
                        dropped.Add(nested.nodes[level - 1][node.backLinkL]);
                    }
                    if(node.backLinkR != -1) {
                        dropped.Add(nested.nodes[level - 1][node.backLinkR]);
                    }
                }

                foreach(TPreparedData.Nested.Node node in dropped) {
                    nested.nodes[level - 1].Remove(node);
                }
            }
            return data;
        }

        /// <summary>
        /// Handler for complex-type arguments
        /// </summary>
        /// <param name="property"></param>
        /// <param name="pattern"></param>
        /// <param name="data">[Modifiable] Unevaluated data</param>
        /// <param name="level">Current level for nested</param>
        /// <returns>Added nodes</returns>
        private List<TPreparedData.Nested.Node> _nestedComplex(TPreparedData.TProperty property, ref string pattern, ref string data, int level)
        {
            int idx         = -1;
            string identLnk = String.Format("!p{0}!", level - 1);

            data = Regex.Replace(data, pattern.Replace("!p!", identLnk), delegate(Match m)
            {
                ++idx;
                if(!m.Groups[2].Success && !m.Groups[4].Success) {
                    return m.Value; // backLink support
                }

                string ret                      = String.Format("!p{0}!", level);
                TPreparedData.Nested.Node node  = new TPreparedData.Nested.Node();
                node.backLinkL                  = -1;
                node.backLinkR                  = -1;

                if(m.Groups[1].Value.Length > 1) {
                    node.data       = m.Value;
                    node.evaluated  = m.Value.Substring(1);
                    node.type       = TPreparedData.Nested.TypeValue.PropertyEscaped;

                    property.nested.nodes[level].Add(node);
                    Log.nlog.Debug("nested: added escaped '{0}' /({1}:{2}) :: level {3}", node.evaluated, node.backLinkL, node.backLinkR, level);
                    return ret;
                }

                node.type = TPreparedData.Nested.TypeValue.Property;
                node.data = m.Groups[m.Groups[2].Success ? 2 : 4].Value.Trim();

                if(m.Groups[3].Success) {
                    node.project = m.Groups[3].Value.Trim();
                }
                else if(m.Groups[5].Success) {
                    node.project = m.Groups[5].Value.Trim();
                }

                // Evaluating for nested 'data:project' - to support variable of variable

                bool dataLinked     = (node.data == identLnk);
                bool projectLinked  = (node.project == identLnk);

                string eData        = node.data;
                string eProject     = node.project;

                if(dataLinked || projectLinked)
                {
                    node.backLinkL = idx;
                    List<TPreparedData.Nested.Node> prev = property.nested.nodes[level - 1];
            
                    string eNode = prev[idx].evaluated == null ? prev[idx].data : prev[idx].evaluated;

                    if(dataLinked && projectLinked) {
                        node.backLinkR  = ++idx;
                        eData           = eNode;
                        eProject        = prev[idx].evaluated == null ? prev[idx].data : prev[idx].evaluated;
                    }
                    else if(dataLinked) {
                        eData = eNode;
                    }
                    else {
                        eProject = eNode;
                    }
                }
                //if(!String.IsNullOrEmpty(eProject) && !_isPropertySimple(ref eProject)) {
                //    //eProject = evaluateVariable(eProject, null); // should be set as part of eData, e.g.: $(project) if needed
                //}
                node.evaluated  = _isPropertySimple(ref eData) ? getProperty(eData, eProject) : evaluateVariable(eData, eProject);

                property.nested.nodes[level].Add(node);
                Log.nlog.Debug("nested: added '{0}':'{1}' == '{2}' /({3}:{4}) :: level {5}",
                                node.data, node.project, node.evaluated, node.backLinkL, node.backLinkR, level);

                return ret;
            }, RegexOptions.IgnorePatternWhitespace);

            return property.nested.nodes[level];
        }

        private string _wrapVariable(ref string var)
        {
            if(!var.StartsWith("$(")) {
                Log.nlog.Debug("wrap: '{0}'", var);
                return String.Format("$({0})", var);
            }
            return var;
        }

        private bool _isPropertySimple(ref string unevaluated)
        {
            if(unevaluated.IndexOfAny(new char[]{'.', ':', '(', ')', '\'', '"', '[', ']'}) != -1) {
                return false;
            }
            return true;
        }
    }

    /// <summary>
    /// item of property: name = value
    /// </summary>
    public struct TMSBuildPropertyItem
    {
        public string name;
        public string value;

        public TMSBuildPropertyItem(string name, string value)
        {
            this.name  = name;
            this.value = value;
        }
    }

    //TODO:
    internal struct SBECustomVariable
    {
        public const string OWP_BUILD           = "vsSBE_OWPBuild";
        public const string OWP_BUILD_WARNINGS  = "vsSBE_OWPBuildWarnings";
        public const string OWP_BUILD_ERRORS    = "vsSBE_OWPBuildErrors";
    }
}
