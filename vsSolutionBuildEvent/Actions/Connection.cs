/* 
 * Boost Software License - Version 1.0 - August 17th, 2003
 * 
 * Copyright (c) 2013-2014 Developed by reg <entry.reg@gmail.com>
 * 
 * Permission is hereby granted, free of charge, to any person or organization
 * obtaining a copy of the software and accompanying documentation covered by
 * this license (the "Software") to use, reproduce, display, distribute,
 * execute, and transmit the Software, and to prepare derivative works of the
 * Software, and to permit third-parties to whom the Software is furnished to
 * do so, all subject to the following:
 * 
 * The copyright notices in the Software and this entire statement, including
 * the above license grant, this restriction and the following disclaimer,
 * must be included in all copies of the Software, in whole or in part, and
 * all derivative works of the Software, unless such copies or derivative
 * works are solely in the form of machine-executable object code generated by
 * a source language processor.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
 * SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
 * FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE. 
*/

using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using Microsoft.VisualStudio;
using Microsoft.VisualStudio.Shell.Interop;
using net.r_eg.vsSBE.Events;

namespace net.r_eg.vsSBE.Actions
{
    public class Connection: IListenerOWPL
    {
        /// <summary>
        /// Ignored all action if value as true
        /// Support of cycle control, e.g.: PRE -> POST [recursive DTE: PRE -> POST] -> etc.
        /// </summary>
        public static volatile bool silent = false;

        /// <summary>
        /// Execution order support.
        /// Contains the current states of all projects
        /// </summary>
        protected Dictionary<string, TExecutionOrder.Type> projects;

        /// <summary>
        /// Contains the current incoming project
        /// </summary>
        protected TExecutionOrder current;

        /// <summary>
        /// Connection handler
        /// </summary>
        protected SBECommand sbe;

        /// <summary>
        /// Checks the allow state for action
        /// </summary>
        protected bool IsAllowActions
        {
            get { return !silent; }
        }

        /// <summary>
        /// TODO: *!* refact. & place to another component for work with scripts
        /// see: https://bitbucket.org/3F/vssolutionbuildevent/issue/19/multi-actions#comment-12799056
        /// </summary>
        protected volatile Dictionary<SolutionEventType, ExecStateType[]> states = new Dictionary<SolutionEventType, ExecStateType[]>();

        protected enum ExecStateType
        {
            Success,
            Fail,
            /// <summary>
            ///  Support of deferred events
            /// </summary>
            Deferred
        }

        public Connection(SBECommand sbe)
        {
            this.sbe = sbe;
            projects = new Dictionary<string, TExecutionOrder.Type>();
        }

        /// <summary>
        /// Binding 'PRE' of Solution
        /// </summary>
        public int bindPre(ref int pfCancelUpdate)
        {
            _flushExecuted();
            if(isDisabledAll(Config._.Data.preBuild)) {
                return VSConstants.S_OK;
            }

            if(!IsAllowActions) {
                return _ignoredAction(SolutionEventType.Pre);
            }

            states[SolutionEventType.Pre] = new ExecStateType[Config._.Data.preBuild.Length];
            int idx = 0;
            foreach(SBEEvent item in Config._.Data.preBuild)
            {
                if(hasExecutionOrder(item)) {
                    Log.nlog.Info("[Pre] SBE has deferred action: '{0}' :: waiting... ", item.caption);
                    states[SolutionEventType.Pre][idx] = ExecStateType.Deferred;
                }
                else {
                    states[SolutionEventType.Pre][idx] = (execPre(item) == VSConstants.S_OK)? ExecStateType.Success : ExecStateType.Fail;
                }
                ++idx;
            }
            return states[SolutionEventType.Pre].Contains(ExecStateType.Fail) ? VSConstants.E_FAIL : VSConstants.S_OK;
        }

        /// <summary>
        /// Binding 'POST' of Solution
        /// </summary>
        public int bindPost(int fSucceeded, int fModified, int fCancelCommand)
        {
            SBEEvent[] evt = Config._.Data.postBuild;

            if(isDisabledAll(evt)) {
                return VSConstants.S_OK;
            }

            if(!IsAllowActions) {
                return _ignoredAction(SolutionEventType.Post);
            }

            states[SolutionEventType.Post] = new ExecStateType[evt.Length];
            for(int i = 0; i < evt.Length; ++i)
            {
                if(fSucceeded != 1 && evt[i].buildFailedIgnore) {
                    Log.nlog.Info("[Post] ignored action '{0}' :: Build FAILED. See option 'Ignore if the build failed'", evt[i].caption);
                    continue;
                }

                if(!isReached(evt[i])) {
                    Log.nlog.Info("[Post] ignored action '{0}' ::  not reached selected projects in execution order", evt[i].caption);
                    continue;
                }

                try {
                    if(sbe.basic(evt[i], SolutionEventType.Post)) {
                        Log.nlog.Info("[Post] finished SBE: {0}", evt[i].caption);
                    }
                    states[SolutionEventType.Post][i] = ExecStateType.Success;
                }
                catch(Exception ex) {
                    Log.nlog.Error("Post-Build error: {0}", ex.Message);
                    states[SolutionEventType.Post][i] = ExecStateType.Fail;
                }
            }
            return states[SolutionEventType.Post].Contains(ExecStateType.Fail) ? VSConstants.E_FAIL : VSConstants.S_OK;
        }

        /// <summary>
        /// Binding 'PRE' of Projects
        /// </summary>
        public int bindProjectPre(IVsHierarchy pHierProj, IVsCfg pCfgProj, IVsCfg pCfgSln, uint dwAction, ref int pfCancel)
        {
            onProject(pHierProj, TExecutionOrder.Type.Before);
            return VSConstants.S_OK;
        }

        /// <summary>
        /// Binding 'POST' of Projects
        /// </summary>
        public int bindProjectPost(IVsHierarchy pHierProj, IVsCfg pCfgProj, IVsCfg pCfgSln, uint dwAction, int fSuccess, int fCancel)
        {
            onProject(pHierProj, TExecutionOrder.Type.After, fSuccess == 1 ? true : false);
            return VSConstants.S_OK;
        }

        /// <summary>
        /// Binding 'Cancel/Abort' of Solution
        /// </summary>
        public int bindCancel()
        {
            SBEEvent[] evt = Config._.Data.cancelBuild;

            if(isDisabledAll(evt)) {
                return VSConstants.S_OK;
            }

            if(!IsAllowActions) {
                return _ignoredAction(SolutionEventType.Cancel);
            }

            states[SolutionEventType.Cancel] = new ExecStateType[evt.Length];
            for(int i = 0; i < evt.Length; ++i)
            {
                if(!isReached(evt[i])) {
                    Log.nlog.Info("[Cancel] ignored action '{0}' :: not reached selected projects in execution order", evt[i].caption);
                    continue;
                }

                try {
                    if(sbe.basic(evt[i], SolutionEventType.Cancel)) {
                        Log.nlog.Info("[Cancel] finished SBE: {0}", evt[i].caption);
                    }
                    states[SolutionEventType.Cancel][i] = ExecStateType.Success;
                }
                catch(Exception ex) {
                    Log.nlog.Error("Cancel-Build error: {0}", ex.Message);
                    states[SolutionEventType.Cancel][i] = ExecStateType.Fail;
                }
            }
            return states[SolutionEventType.Cancel].Contains(ExecStateType.Fail) ? VSConstants.E_FAIL : VSConstants.S_OK;
        }

        public void updateContext(SBECommand.ShellContext context)
        {
            sbe.updateContext(context);
        }

        /// <summary>
        /// Listener of raw OWP
        /// </summary>
        void IListenerOWPL.raw(string data)
        {
            if(!IsAllowActions)
            {
                if(!isDisabledAll(Config._.Data.transmitter)) {
                    _ignoredAction(SolutionEventType.Transmitter);
                }
                else if(!isDisabledAll(Config._.Data.warningsBuild)) {
                    _ignoredAction(SolutionEventType.Warnings);
                }
                else if(!isDisabledAll(Config._.Data.errorsBuild)) {
                    _ignoredAction(SolutionEventType.Errors);
                }
                else if(!isDisabledAll(Config._.Data.outputCustomBuild)) {
                    _ignoredAction(SolutionEventType.OWP);
                }
                return;
            }

            //states[SolutionEventType.Transmitter] = new ExecStateType[Config._.Data.transmitter.Length];
            int idx = 0;
            foreach(SBETransmitter evt in Config._.Data.transmitter)
            {
                if(!isExecute(evt, current)) {
                    Log.nlog.Info("[Transmitter] ignored action '{0}' :: by execution order", evt.caption);
                }
                else {
                    try {
                        if(sbe.supportOWP(evt, SolutionEventType.Transmitter, data)) {
                            //Log.nlog.Trace("[Transmitter]: " + Config._.Data.transmitter.caption);
                        }
                        //states[SolutionEventType.Transmitter][idx] = ExecStateType.Success;
                    }
                    catch(Exception ex) {
                        Log.nlog.Error("Transmitter error: {0}", ex.Message);
                        //states[SolutionEventType.Transmitter][idx] = ExecStateType.Fail;
                    }
                }
                ++idx;
            }

            OutputWPBuildParser res = new OutputWPBuildParser(ref data);

            //TODO: ExecStateType

            foreach(SBEEventEW evt in Config._.Data.warningsBuild) {
                if(evt.enabled) {
                    sbeEW(evt, OutputWPBuildParser.Type.Warnings, res);
                }
            }

            foreach(SBEEventEW evt in Config._.Data.errorsBuild) {
                if(evt.enabled) {
                    sbeEW(evt, OutputWPBuildParser.Type.Errors, res);
                }
            }

            foreach(SBEEventOWP evt in Config._.Data.outputCustomBuild) {
                if(evt.enabled) {
                    sbeOutput(evt, ref data);
                }
            }
        }

        /// <summary>
        /// Entry point to Errors/Warnings
        /// </summary>
        protected int sbeEW(ISolutionEventEW evt, OutputWPBuildParser.Type type, OutputWPBuildParser info)
        {
            // TODO: capture code####, message..
            if(!info.checkRule(type, evt.isWhitelist, evt.codes)) {
                return VSConstants.S_OK;
            }

            if(!isExecute(evt, current)) {
                Log.nlog.Info("[{0}] ignored action '{1}' :: by execution order", type, evt.caption);
                return VSConstants.S_OK;
            }

            try {
                if(sbe.basic(evt, type == OutputWPBuildParser.Type.Warnings ? SolutionEventType.Warnings : SolutionEventType.Errors)) {
                    Log.nlog.Info("[{0}] finished SBE: {1}", type, evt.caption);
                }
                return VSConstants.S_OK;
            }
            catch(Exception ex) {
                Log.nlog.Error("SBE '{0}' error: {1}", type, ex.Message);
            }
            return VSConstants.E_FAIL;
        }

        /// <summary>
        /// Entry point to the OWP
        /// </summary>
        protected int sbeOutput(ISolutionEventOWP evt, ref string raw)
        {
            if(!(new OWPMatcher()).match(evt.eventsOWP, raw)) {
                return VSConstants.S_OK;
            }

            if(!isExecute(evt, current)) {
                Log.nlog.Info("[Output] ignored action '{0}' :: by execution order", evt.caption);
                return VSConstants.S_OK;
            }

            try {
                if(sbe.basic(evt, SolutionEventType.OWP)) {
                    Log.nlog.Info("[Output] finished SBE: {0}", evt.caption);
                }
                return VSConstants.S_OK;
            }
            catch(Exception ex) {
                Log.nlog.Error("SBE 'Output' error: {0}", ex.Message);
            }
            return VSConstants.E_FAIL;
        }

        /// <summary>
        /// Immediately execute 'PRE' of Solution
        /// </summary>
        protected int execPre(SBEEvent evt)
        {
            try {
                if(sbe.basic(evt, SolutionEventType.Pre)) {
                    Log.nlog.Info("[Pre] finished SBE: {0}", evt.caption);
                }
                return VSConstants.S_OK;
            }
            catch(Exception ex) {
                Log.nlog.Error("Pre-Build error: {0}", ex.Message);
            }
            return VSConstants.E_FAIL;
        }

        protected int execPre()
        {
            int idx = 0;
            foreach(SBEEvent item in Config._.Data.preBuild) {
                if(hasExecutionOrder(item)) {
                    states[SolutionEventType.Pre][idx] = execPre(item) == VSConstants.S_OK ? ExecStateType.Success : ExecStateType.Fail;
                }
                ++idx;
            }
            return states[SolutionEventType.Pre].Contains(ExecStateType.Fail) ? VSConstants.E_FAIL : VSConstants.S_OK;
        }

        protected string getProjectName(IVsHierarchy pHierProj)
        {
            object name;
            // http://msdn.microsoft.com/en-us/library/microsoft.visualstudio.shell.interop.ivshierarchy.getproperty.aspx
            // http://msdn.microsoft.com/en-us/library/microsoft.visualstudio.shell.interop.__vshpropid.aspx
            pHierProj.GetProperty((uint)VSConstants.VSITEMID.Root, (int)__VSHPROPID.VSHPROPID_Name, out name);

            return name.ToString();
        }

        /// <summary>
        /// Checking state from incoming projects
        /// In general, this checking for single the event-action like a POST/Cacnel
        /// note: 
        ///   * The 'POST' - exists as successfully completed event, therefore we should getting only the 'After' state.
        ///   * The 'Cancel' - works differently and contains realy the reached state: 'Before' or 'After'.
        /// </summary>
        protected bool isReached(ISolutionEvent evt)
        {
            if(!hasExecutionOrder(evt)) {
                return true;
            }
            Log.nlog.Debug("hasExecutionOrder(->isReached) for '{0}' is true", evt.caption);

            return evt.executionOrder.Where(e =>
                                              projects.ContainsKey(e.project)
                                               && projects[e.project] == e.order
                                            ).Count() > 0;
        }

        /// <summary>
        /// Checking state with current range of order.
        /// 
        /// In general, this checking for multiple the event-action like a EW/OWP:
        ///   * Before1 -> After1|Cancel
        ///   * After1  -> POST/Cancel
        /// </summary>
        /// <param name="evt"></param>
        /// <param name="incoming">Current incoming project</param>
        /// <returns>true value if it's allowed to execute for current state</returns>
        protected bool isExecute(ISolutionEvent evt, TExecutionOrder incoming)
        {
            if(!hasExecutionOrder(evt)) {
                return true;
            }
            Log.nlog.Debug("hasExecutionOrder(->isExecute) for '{0}' is true", evt.caption);

            foreach(TExecutionOrder eo in evt.executionOrder)
            {
                if(!projects.ContainsKey(eo.project)) {
                    continue;
                }

                // The 'Before' base:
                if(eo.order == TExecutionOrder.Type.Before)
                {
                    // Before1 -> After1
                    return (projects[eo.project] == TExecutionOrder.Type.Before);
                }

                // The 'After' base:
                if(projects[eo.project] != TExecutionOrder.Type.After) {
                    return false; // waiting for 'After' state..
                }

                if(incoming.project != eo.project) {
                    return true; // After1  -> POST/Cancel
                }
                return (incoming.order == TExecutionOrder.Type.After); // 'After' is reached ?
            }
            return false;
        }

        protected void onProject(IVsHierarchy pHierProj, TExecutionOrder.Type type, bool fSuccess = true)
        {
            string project      = getProjectName(pHierProj);
            projects[project]   = type;

            current.project = project;
            current.order   = type;

            Log.nlog.Trace("onProject: '{0}':{1} == {2}", project, type, fSuccess);

            if(states[SolutionEventType.Pre].Contains(ExecStateType.Deferred)) {
                monitoringPre(project, type, fSuccess);
            }
        }

        /// <summary>
        /// Monitoring for deferred PRE-actions - "it's time or not"
        /// </summary>
        /// <param name="project">incoming project name</param>
        /// <param name="type">type of execution order</param>
        /// <param name="fSuccess">Flag indicating success</param>
        protected void monitoringPre(string project, TExecutionOrder.Type type, bool fSuccess)
        {
            SBEEvent[] evt = Config._.Data.preBuild;
            for(int i = 0; i < evt.Length; ++i)
            {
                if(!evt[i].enabled || states[SolutionEventType.Pre][i] != ExecStateType.Deferred) {
                    continue;
                }

                if(!IsAllowActions) {
                    _ignoredAction(SolutionEventType.DeferredPre);
                    return;
                }

                if(!fSuccess && evt[i].buildFailedIgnore) {
                    Log.nlog.Info("[PRE] ignored action '{0}' :: Build FAILED. See option 'Ignore if the build failed'", evt[i].caption);
                    continue;
                }

                if(!hasExecutionOrder(evt[i])) {
                    Log.nlog.Trace("[PRE] deferred: executionOrder is null or not contains elements :: {0}", evt[i].caption);
                    return;
                }

                if(evt[i].executionOrder.Where(o => o.project == project && o.order == type).Count() > 0) {
                    Log.nlog.Info("Incoming '{0}'({1}) :: Execute the deferred action: '{2}'", project, type, evt[i].caption);
                    states[SolutionEventType.Pre][i] = (execPre(evt[i]) == VSConstants.S_OK) ? ExecStateType.Success : ExecStateType.Fail;
                }
            }
        }

        /// <param name="evt">Array of handling events</param>
        /// <returns>true value if all event are disabled for present array</returns>
        protected bool isDisabledAll(ISolutionEvent[] evt)
        {
            foreach(ISolutionEvent item in evt) {
                if(item.enabled) {
                    return false;
                }
            }
            return true;
        }

        protected bool hasExecutionOrder(ISolutionEvent evt)
        {
            if(evt.executionOrder == null || evt.executionOrder.Length < 1) {
                return false;
            }
            return true;
        }

        private int _ignoredAction(SolutionEventType type)
        {
            Log.nlog.Trace("[{0}] ignored action. Is already started from another VSprocess.", type);
            return VSConstants.S_OK;
        }

        private void _flushExecuted()
        {
            projects.Clear();
            states.Clear();
        }
    }
}
